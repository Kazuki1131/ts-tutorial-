// as const
{
    // TypeScriptに型推論の方法を指示するための構文です。
    // as constは、各種リテラル（文字列・数値・真偽値のリテラル、オブジェクトリテラル・配列リテラル）に付加することができ、
    // その値が書き換えを意図していない値であることを表します。
    // この記事の最初のほうでリテラル型の型推論について説明したのを覚えているでしょうか。
    // リテラル型の値をvarやletで宣言した変数に入れると、その値があとから書き換えられるかもしれないためリテラル型ではなく対応するプリミティブ型が推論されるのでした。
    {
		// foo は string 型
		let foo = "123";
	}

    // では、この'123'にas constを付けるとどうなるでしょうか。それが次の例です。
    {
		// foo2 は "123" 型
		var foo2 = "123" as const;
	}

    // このようにas constを付けると'123'は書き換えられることを意図していない値として扱われるため、変数foo2はstring型ではなく"123"型となります。
    // ここまでの話はconstを使えば済むような話でしたが、as constの本領はここからです。次に、オブジェクトリテラルの例を見ましょう。
    {
		// obj は { foo: string; bar: number[] } 型
		const obj = {
			foo: "123",
			bar: [1, 2, 3],
		};

		/*
            obj2 は
            {
                readonly foo: "123";
                readonly bar: readonly [1, 2, 3];
            }
            型
        */
		const obj2 = {
			foo: "123",
			bar: [1, 2, 3],
		} as const;
	}

    // まず、as const無しのobjの型は{ foo: string; bar: number[] }型となっています。
    // 注目すべき点は、例えばfooプロパティの型が"123"型ではなくstring型となっている点です。
    // これは"123"をvarやletの変数に入れたときと同じ挙動ですね。
    // オブジェクトのプロパティは（readonlyでない限り）obj.foo = "456";のように書き換えることができるので、普通はリテラル型がつかないのです。
    // 一方、as constをオブジェクトリテラルに付けたobj2の場合は、fooプロパティには"123"型がついています。
    // また、fooプロパティ自体もreadonlyになっています。
    // 後者は、obj2は書き換えることを意図していないオブジェクトであるためobj2.foo = "456";のような変更を禁止するためにreadonlyとなっているわけですね。
    // また、as constは再帰的にその中身にも適用されるため、中の"123"も"123" as const相当になり、型がstringではなく"123"型になっています。
    // barについても同様です。配列リテラルにas constを使用した場合は対応するreadonlyタプル型が推論されます。
    // この場合、[1, 2, 3] as constの型がreadonly [1, 2, 3]と推論されることから、obj2.barの型もreadonly [1, 2, 3]型となっています。
    // readonly [number, number, number]ではなくreadonyly [1, 2, 3]になっているのは、やはり配列リテラルの中身についてもas constが適用されているからです。
    // 他にも、as constはテンプレート文字列リテラルに対しても特殊な効果を持ちます。
    // テンプレート文字列リテラルの型は通常string型となりますが、as constが適用された場合はテンプレートリテラル型が得られます。

    // 他にも、as constはテンプレート文字列リテラルに対しても特殊な効果を持ちます。
    // テンプレート文字列リテラルの型は通常string型となりますが、as constが適用された場合はテンプレートリテラル型が得られます。
    {
        const world: string = "world";

        // string型
        const str1 = `Hello, ${world}!`;
        // `Hello, ${string}!` 型
        const str2 = `Hello, ${world}!` as const;
    }
    // このように、as constはリテラルの型推論で型を広げてほしくないときに使用することができます。
    // as constをリテラルにつけたときに推論される型の挙動をまとめるとこのようになります。
    {
        // 文字列・数値・真偽値リテラルはそれ自体のリテラル型を持つものとして推論されます。（例： "foo" as constは"foo"型）
        // テンプレート文字列リテラルはテンプレートリテラル型に推論されます。
        // オブジェクトリテラルは各プロパティがreadonlyを持つようになります。
        // 配列リテラルの型はreadonlyタプル型になります。
    }
}
