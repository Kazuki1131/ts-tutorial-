// unknown
{
    // TypeScript3.0から、本当に最も弱い型であるunknown型が利用可能になりました。
    // どんな型の値もunknown型として扱うことができます。 難しい言葉で言うと、これはいわゆるtop型です。
    // すなわち、never型のちょうど逆にあたる、すべての型を部分型として持つような、部分型関係の頂点にある型です。
    {
        const u1: unknown = 3;
		const u2: unknown = null;
		const u3: unknown = (foo: string) => true;
    }

    // 任意の値を取ることができるというのはany型と同じ特徴ですが、unknown型はany型とは異なり安全に扱うことができる型です。
    // というのも、unknown型の値はどんな値なのか分からないため、できることが制限されているのです。
    // 例えば、数値の足し算をすることもできませんし、プロパティアクセスもできません。
    {
        const u: unknown = 3;
		// エラー: Object is of type 'unknown'.
		const sum = u + 5;
		// エラー: Object is of type 'unknown'.
		const p = u.prop;
    }

    // このように、どんな値でもいい、最悪nullやundefinedかもしれないということは、その値に対してほとんど何も出来ないことを意味しているのです。
    // 従来、関数の引数などが「どんな値でもいい」ことを表したい場合にはanyなどが主に使われてきましたが、
    // any型の値は型システムを無視して好きなように扱うことができて危ない型だったので、代わりにunknown型を使うことが有効です。
    // unknown型の値を使いたいときは、union型と同様に型の絞り込みが可能です。
    // これにより、unknown型の値として受け取った値が特定の型のときにのみ処理をするということが可能になります。
    {
        const u: unknown = 3;

		if (typeof u === "number") {
			// この中ではuはnumber型
			const foo = u + 5;
		}
    }

    // また、クラスの型とinstanceofを組み合わせることによる絞り込みも可能です。
    {
        const u: unknown = 3;

        class MyClass {
            public prop: number = 10;
        }

        if (u instanceof MyClass) {
            // ここではuはMyClass型
            u.prop;
        }
    }

    // unknown型とvoid型の意外な関係
    {
		// 実は、unknown型とvoid型は結構似ているところがあります。
		// それは関数の返り値の型としてvoid型が登場する場合に現れます。
		// 次の例は正しいTypeScriptコードです（コンパイルエラーが起きません）。
		{
			const func1: () => number = () => 123;

			const f: () => void = func1;

            // ここでfunc1は() => number型、つまり数値を返す関数です。
            // 上の例は、これを() => void型として扱っても良いということを表しています。
            // ここがvoid型の特殊なところで、部分型関係においてvoid型はunknown型と同様の振る舞いをします。
            // ただし、この記事の序盤で説明したように、void型を（関数の返り値などではなく）直に扱う場合は追加の制限が入ります（これにより、const v: void = 123のようなものはエラーとなります）。
            // これは特にアロー関数と組み合わせた場合に役に立つ挙動です。
            // func1を呼びたいけど返り値には興味がない場合、() => func1()のようなアロー関数を作るとこれは() => number型となります。
            // しかし返り値はどうでもいいので気持ち的にはこれは() => void型とも言えますね。
            // この気持ちをうまく表現するために、このような関数を() => void型として扱えるようになっているのです。
            // ということは、裏を返せば返り値がvoid型の関数の返り値は何が入っているのか全くわからないということになります。
            // 上の例に続けて以下を実行したとすると、void型の変数voidValueの中身は実は123になります。

            const voidValue: void = f();
            console.log(voidValue); // 123 が表示される

            // なので、void型の値を得てもそれがundefinedである保証すら無いことになります。
            // void型を持つ値の挙動はやはりunknown型と似ており、基本的に使うことができません（unknown型として使うことはできます）。
            // ということで、実はvoid型というのはunknownにさらに追加の制限が加わった型という見方ができるのでした。
            // 登場したのはunknown型の方が後なのですが。
        }
    }
}
